# Copyright (C) 2007-2008 Michael Homer <=mwh>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


def _clone(ofunc, nfunc):
    """Copy the metadata from `ofunc` onto `nfunc`."""
    nfunc.__name__ = ofunc.__name__
    nfunc.__doc__ = ofunc.__doc__
    nfunc.__module__ = ofunc.__module__
    nfunc.__dict__.update(ofunc.__dict__)


def decorator(decorator):
    """A decorator to make writing decorators simpler.

    Decorator methods can be decorated with this, and then written in
    the form of simple methods with the signature (function,*args,**kw)
    that perform some action and then call the function.
    """

    def new(func):

        def new2(*args, **kw):
            return decorator(func, *args, **kw)
        _clone(func, new2)
        return new2
    return new


@decorator
def memoised(func, *args, **kw):
    """Decorator to impose magic memoisation on a method.

    All parameters to the method *must* be hashable. Values are stored
    in a dictionary `_cache` on the function object.
    """
    if not hasattr(func, '_cache'):
        func._cache = dict()
    key = args
    if kw: # This is an unpleasant hack.
        key = (args, tuple(list(kw.items())))
    d = func._cache
    if key in d:
        return d[key]
    result = func(*args, **kw)
    d[key] = result
    return result


@decorator
def logged(func, *args, **kw):
    """Decorator to log calls to a method transparently."""
    import sys
    sys.stderr.write("Calling %s with %r"%(func.__name__, args))
    return func(*args, **kw)


def deprecated(major, minor, patch):
    """Mark a method as deprecated and raise a warning when called.

    Version parameters are included in the warning message, and may be
    used to find and remove long-deprecated methods.
    """

    def new(func):
        msg = "%s is deprecated as of %i.%i.%i"%(
                func.__name__, major, minor, patch)

        def new2(*args, **kw):
            import warnings
            warnings.warn(msg, DeprecationWarning, 2)
            return func(*args, **kw)
        _clone(func, new2)
        return new2
    return new


def subscriptable(func):
    """Allow a function to be called as func[x] meaning func(x)."""

    class MethodReplacement:
        """Class to proxy a method, making it callable with () or [].

        This class is necessary because function objects are not
        subscriptable even when __getitem__ is defined on them,
        presumably for optimisation reasons.
        """

        def __init__(self):
            self.func = func
            self.__name__ = func.__name__
            self.__doc__ = func.__doc__
            self.__dict__.update(func.__dict__)

        def __call__(self, *args):
            return self.func(*args)

        def __getitem__(self, *args):
            return self.func(*args)
    mr = MethodReplacement()
    _clone(func, mr)
    return mr
